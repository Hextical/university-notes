\makeheading{2020-02-12}
\begin{algbox}
    \begin{algorithm}[H]
        \DontPrintSemicolon{}
        \caption{Decoding Algorithm for $ C_{24} $}
        \SetKwInOut{Input}{Input}
        \SetKwInOut{Output}{Output}

        \Input{$ G=\left[ \;I_{12}\mid B\; \right]=(\bm{g}_1,\ldots ,\bm{g}_{24})^\top $,
        and $ \tilde{G}=\left[ \;B\mid I_{12} \;\right]=(\tilde{\bm{g}}_1,\ldots, \tilde{\bm{g}}_{24})^\top $,
        and received vector $ \bm{r}=(\bm{x},\bm{y}) $}
        \Output{Decoded vector}
        $ \bm{s}_1\gets G\bm{r}^\top $\;
        \If{$ \bm{s}_1=\bm{0} $} {
            \Return{$ \bm{r} $}
        }
        \If{$ w(\bm{s}_1)\leqslant 3 $} {
            \For{$ i $ \KwTo{} $ 12 $} {
                $ \bm{x}^\prime \gets $ corrected $ \bm{x} $ in each position
                corresponding to $ 1 $'s in $ \bm{s}_1 $\;
                \Return{$ (\bm{x}^\prime,\bm{y}) $}
            }
        }
        \For{$ i\gets 0 $ \KwTo{} $ 24 $} {
            \If{$ \bm{g}_i $ differs in position $ j $ or
                positions $ j $ and $ k $ from $ \bm{s}_1 $} {
                $ \bm{x}^\prime\gets(x_1,\ldots ,x_{12}) $ where $ x_j\gets\overline{x}_j $ or
                $ x_j\gets\overline{x}_j $ and $ x_k\gets\overline{x}_k $\;
                $ \bm{y}^\prime \gets(y_1,\ldots ,y_{12}) $ where $ y_i\gets\overline{y}_i $\;
                \Return{$ (\bm{x}^\prime,\bm{y}^\prime) $}\;
            }
        }
        $ \bm{s}_2\gets\tilde{G}\bm{r}^\top $\;
        \If{$ w(\bm{s}_2)\leqslant 3 $} {
            $ \bm{y}^\prime \gets $ corrected $ \bm{y} $ in each position
            corresponding to $ 1 $'s in $ \bm{s}_2 $\;
            \Return{$ (\bm{x},\bm{y}^\prime) $}
        }
        \For{$ i\gets 0 $ \KwTo{} $ 24 $} {
            \If{$ \tilde{\bm{g}_i} $ differs in position $ j $ or
                positions $ j $ and $ k $ from $ \bm{s}_2 $} {
                $ \bm{y}^\prime \gets (y_1,\ldots ,y_{12}) $ where $ y_j\gets\overline{y}_j $ or
                $ y_j\gets\overline{y}_j $ and $ y_k\gets\overline{y}_k $\;
                $ \bm{x}^\prime\gets(x_1,\ldots ,x_{12}) $ where $ x_i\gets\overline{x}_i $\;
                \Return{$ (\bm{x}^\prime,\bm{y}^\prime) $}\;
            }
        }
        \Return{}
    \end{algorithm}
\end{algbox}

\begin{exbox}
    \begin{example}[Decoding Algorithm for C24]
        $ \; $

        (i) Decode $ \bm{r}=(1000\; 1000\; 0000\; 1001\; 0001\; 1101) $.

        \textbf{Solution.} Compute $ \bm{s}_1=\left[ \; I_{12}\mid B \; \right]\bm{r}^\top=
            (0100\; 1000\; 0000)^\top $. Since $ w(\bm{s}_1)\leqslant 3 $, we set
        $ \bm{e}=(\bm{s}_1^\top,0) $ and decode $ \bm{r} $ to
        \[ \bm{c}=\bm{r}-\bm{e}=(1100\; 0000\; 0000\; 1001\; 0001\; 1101) \]

        (ii) Decode $ \bm{r}=(1000\; 0010\; 0000\; 1000\; 1101\; 0010) $.

        \textbf{Solution.} Compute $ \bm{s}_1=\left[ \; I_{12}\mid B \; \right]\bm{r}^\top=
            (1011\; 1110\; 1011)^\top $. Note that $ w(\bm{s}_1)>3 $. Comparing $ \bm{s}_1 $
        with the rows of $ B $, we see that $ \bm{s}_1 $ differs in positions $ 6 $
        and $ 7 $ from row $ 4 $ of $ B $. Hence we set $ \bm{e}=(0000\; 0110\; 0000\; 0001\; 0000\; 0000) $
        and decode $ \bm{r} $ to
        \[ \bm{c}=\bm{r}-\bm{e}=(1000\; 0100\; 0000\; 1001\; 1101\; 0010) \]

        NOTE\@: In both examples we should check out answers by verifying that $ H\bm{c}^\top=\bm{0} $
        (i.e., $ \bm{c} $ is indeed a codeword).
    \end{example}
\end{exbox}

\textbf{Note:}
\begin{enumerate}[label=(\arabic*)]
    \item If $ w(\bm{e})\leqslant 3 $, then the algorithm makes the correct decision.
    \item No storage is needed:
          \[ \bm{s}_1=\left[ \; I_{12}\mid B\; \right]\bm{r}^\top=\left[ \; I_{12}\mid B\; \right]
              \begin{bmatrix}
                  \bm{x} \\
                  \bm{y}
              \end{bmatrix}=\bm{x}+B\bm{y} \]
          where $ B $ is a left cyclic shift of the first row.
    \item The algorithm is very simple and efficient for hardware.
\end{enumerate}

\subsection{Reliability of C24}
\begin{itemize}
    \item $ p = $ symbol error probability
    \item $ C=\{\bm{c}_1,\ldots ,\bm{c}_M\} $
    \item $ w_i = $ probability that the decoding algorithm makes an incorrect
          decision if $ \bm{c}_i $ is sent.
    \item $ P_C=\frac{1}{M} \sum\limits_{i=1}^{M} w_i $ error probability of $ C $.
    \item $ 1-P_C $ = reliability of $ C $ (correct decision)
\end{itemize}

\begin{table}[H]
    \centering
    \begin{tabularx}{\linewidth}{@{}YYYYY@{}}
        $ p $     & $ (1-p)^{12} $ & $ 1-P_{C_{24}} $     & $ 1-P_T $                        & $ 1-P_H $                          \\
        \midrule
        $ 0.1 $   & $ 0.28243 $    & $ 0.785738      $    & $ 0.71121      $                 & $ 0.549043       $                 \\
        $ 0.01 $  & $ 0.886385 $   & $ 0.999909      $    & $ 0.99643      $                 & $ 0.99037       $                  \\
        $ 0.001 $ & $ 0.988066 $   & $ \approx 1    $     & $ 0.999964     $                 & $ 0.999896        $                \\
        Rate      & $ 1        $   & $ \sfrac{1}{2}=0.5 $ & $ \sfrac{1}{3}=0.3\overline{3} $ & $ \sfrac{11}{15}= 0.7\overline{3}$ \\
    \end{tabularx}
\end{table}


(1) If no source is used, then the reliability for $ 12 $-bit messages is
\[ (1-p)^{12} \]
(2) $ C_{24} $
\[ 1-P_{C_{24}}=\left[ (1-p)^{24}+\binom{24}{1}p(1-p)^{23}+\binom{24}{2}p^2(1-p)^{22}
        + \binom{24}{3}p^3 (1-p)^{21} \right] \]

(3) Triplication Code $ T $
\[ 1-P_T=\left[ (1-p)^3+3p(1-p)^2 \right]^{12} \]

(4) $ (15,11) $-binary Hamming Code
\[ 1-P_H=(1-p)^{15}+15p(1-p)^{14} \]
