\section{2020-01-09}
It's strongly recommend that you \textbf{do not} memorize these commands presented,
you should try them out on your own to see what the output is.

\begin{itemize}
    \item \code{CTRL + C} \textrightarrow{} send kill signal
    \item \code{CTRL + D} \textrightarrow{} send EOF (end-of-file)
    \item NAME\@: \code{cat} \textrightarrow{} concatenate files and print on the standard output
          \begin{itemize}
              \item SYNOPSIS\@: \code{cat [OPTION]\textellipsis{} [FILE]}
              \item DESCRIPTION\@: Concatenate FILE(s) to standard output.
                    With no \code{FILE}, or when \code{FILE} is \code{-}, read standard input.
          \end{itemize}
    \item \code{>} \textrightarrow{} output redirection, overwrites files
          \begin{itemize}
              \item \code{cat > out.txt} \textrightarrow{} redirects output produced by
                    \code{cat} to the file \code{out.txt}
              \item \code{cat t1.txt > t2.txt} \textrightarrow{} redirects all text from
                    \code{t1.txt} to \code{t2.txt}
          \end{itemize}
    \item \code{>{}>} \textrightarrow{} appends at the end of the file instead of overwriting like
          \code{>}
    \item \code{<} \textrightarrow{} input redirection
          \begin{itemize}
              \item \code{cat < sample.txt} \textrightarrow{}
                    input redirection, the shell handles this
              \item \code{cat sample.txt} \textrightarrow{}
                    \code{cat} handles this
              \item \code{cat -n < in > out} \textrightarrow{}
                    \code{-n} numbers all output lines. Input redirect from file \code{in} to
                    \code{cat}, then output redirect with numbered lines to file \code{out}.
          \end{itemize}
\end{itemize}

\subsection{Linux Streams}

\begin{itemize}
    \item \textbf{1. Standard input (stdin)}
          \begin{itemize}
              \item keyboard
              \item use \code{<} to change to file
          \end{itemize}
    \item \textbf{2. Standard output (stdout)}
          \begin{itemize}
              \item terminal
              \item use \code{1>} to change to file; the \code{1} before the \code{>} is optional
              \item buffered
          \end{itemize}
    \item \textbf{3. Standard error (stderr)}
          \begin{itemize}
              \item terminal
              \item use \code{2>} to change to file
              \item non-buffered
          \end{itemize}
\end{itemize}

We use the non-buffered stream when we immediately want to output an error
so that it does not take extra CPU cycles (extra material).

Within the stream,

\code{stdin} \textrightarrow{} program \textrightarrow{}
1. \code{stdout} and 2. \code{stderr}

\code{prog arg1 < in > out 2>\&1} \textrightarrow{}
\code{\&1} is the location of \code{stdout}, so any errors will be redirected to
\code{stdout}.

\subsection{Wildcard Matching}
$ \underbrace{\code{ls *.txt}}_{\text{globbing pattern}} \rightarrow{} $
match anything that ends with \code{.txt}. The shell performs this operation.

Using single/double quotes will suppress globbing patterns.

\code{\textbackslash} is the escape character

\textbf{Example}

Count the number of words in the first 15 lines of \code{sample.txt}.

\textbf{Solution.}

\begin{itemize}
    \item \code{wc -w} \textrightarrow{} print number of words in entire text
    \item \code{head -15 sample.txt} \textrightarrow{} get only the first 15 lines
          of \code{sample.txt}
    \item \code{head -15 sample.txt > temp.txt wc -w temp.txt} \textrightarrow{}
          doing both, with output in a \code{temp.txt} file.
\end{itemize}

What if we didn't want \code{temp.txt} to be produced? We use Linux pipes.

\subsection{Linux Pipe}
Connect \code{stdout} of prog1 to \code{stdin} of prog2.

\code{head -15 sample.txt | wc -w} \textrightarrow{}
the first program, \code{head} runs with \code{sample.txt}, then the output is fed into
the second program, \code{wc}.

\textbf{Example}

Suppose \code{words*.txt} contains one word per line. Produce
a list of words sorted, with no duplicates from \code{words*.txt}.

\textbf{Solution.}

\code{cat words*.txt | sort -u} OR
\code{cat words*.txt | sort | uniq} \textrightarrow{} \code{sort -u} will sort
and remove any duplicate words. \code{uniq} removes duplicates.

\code{echo Today is \$(date)} \textrightarrow{}
\code{\$(date)} is embedding a command date

Double quotes: does not suppress embedded commands

Single quotes: suppresses embedded commands
