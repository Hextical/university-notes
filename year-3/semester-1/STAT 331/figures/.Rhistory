## 248 Burmese pythons (Python bivittatus) collected in the Florida Everglades
python <- read.csv("FLpython.csv")
head(python)
python$male <- ifelse(python$sex == 'M', 1, 0) # 1 = M, 0 =F
cor(python[,-1])
pairs(python[,-1])
mpf <- lm(fat ~ male + svl + mass + length, data = python)
summary(mpf)
vif(mpf)
# remove "length" based on VIF
mpf2 <- lm(fat ~ male + mass + svl, data = python)
summary(mpf2)
vif(mpf2)
library(car)
# Chunk 1
## Coffee example  (Coffee Quality Institute, 2018) continued
coffee <- read.csv("coffee_arabica.csv")
# cor(coffee) # doesn't work as there's a categorical variable
cor(coffee[,-1]) # e.g., remove first column
# pairs without response: pairs(coffee[,-1])
# pairs with response, this is what we want
pairs(~ Flavor + Aroma + Aftertaste + Body +
Acidity + Balance + Sweetness + Uniformity + Moisture, data=coffee)
# Code our own indicators, so that we can more easily interpret VIFs
# 1 = wet, 0 otherwise
coffee$wet <- ifelse(coffee$Processing.Method == 'Washed / Wet', 1, 0)
# 1 = semi/dry, 0 otherwise
coffee$semi <- ifelse(coffee$Processing.Method == 'Semi-washed / Semi-pulped',
1, 0)
# Chunk 2
# Full MLR with our own coded indicators
mfull <- lm(Flavor~ wet + semi + Aroma + Aftertaste +
Body + Acidity + Balance + Sweetness + Uniformity + Moisture, dat=coffee)
summary(mfull)
# Full MLR alternative, using factor command
mfull_alternative <- lm(Flavor~ factor(Processing.Method) + Aroma + Aftertaste +
Body + Acidity + Balance + Sweetness + Uniformity + Moisture, dat=coffee)
# Chunk 3
wet_reg <- lm(wet ~ semi + Aroma + Aftertaste + Body + Acidity + Balance +
Sweetness + Uniformity + Moisture,dat=coffee)
summary(wet_reg)
r2_wet <- summary(wet_reg)$r.squared
r2_wet
# Chunk 4
VIF_wet <- 1 / (1 - r2_wet)
VIF_wet
# Chunk 5
Aroma_reg <- lm(Aroma ~ wet + semi + Aftertaste +
Body + Acidity + Balance + Sweetness + Uniformity + Moisture, dat=coffee)
r2_Aroma <- summary(Aroma_reg)$r.squared
r2_Aroma
VIF_Aroma <- 1 / (1 - r2_Aroma)
VIF_Aroma
# Chunk 6
Aftertaste_reg <- lm(Aftertaste ~ wet + semi + Aroma +
Body + Acidity + Balance + Sweetness + Uniformity + Moisture, dat=coffee)
r2_Aftertaste <- summary(Aftertaste_reg)$r.squared
r2_Aftertaste
VIF_Aftertaste <- 1 / (1 - r2_Aftertaste)
VIF_Aftertaste
library(car)
vif(mfull) # VIF function in the "car" library
# Chunk 7
## Python in FL everglades example (2017)
## Sex, length, total mass, fat mass, and specimen condition data for
## 248 Burmese pythons (Python bivittatus) collected in the Florida Everglades
python <- read.csv("FLpython.csv")
head(python)
python$male <- ifelse(python$sex == 'M', 1, 0) # 1 = M, 0 =F
cor(python[,-1])
pairs(python[,-1])
mpf <- lm(fat ~ male + svl + mass + length, data = python)
summary(mpf)
vif(mpf)
# remove "length" based on VIF
mpf2 <- lm(fat ~ male + mass + svl, data = python)
summary(mpf2)
vif(mpf2)
# Chunk 1
## Coffee example  (Coffee Quality Institute, 2018) continued
coffee <- read.csv("coffee_arabica.csv")
# cor(coffee) # doesn't work as there's a categorical variable
cor(coffee[,-1]) # e.g., remove first column
# pairs without response: pairs(coffee[,-1])
# pairs with response, this is what we want
pairs(~ Flavor + Aroma + Aftertaste + Body +
Acidity + Balance + Sweetness + Uniformity + Moisture, data=coffee)
# Code our own indicators, so that we can more easily interpret VIFs
# 1 = wet, 0 otherwise
coffee$wet <- ifelse(coffee$Processing.Method == 'Washed / Wet', 1, 0)
# 1 = semi/dry, 0 otherwise
coffee$semi <- ifelse(coffee$Processing.Method == 'Semi-washed / Semi-pulped',
1, 0)
# Chunk 2
# Full MLR with our own coded indicators
mfull <- lm(Flavor~ wet + semi + Aroma + Aftertaste +
Body + Acidity + Balance + Sweetness + Uniformity + Moisture, dat=coffee)
summary(mfull)
# Full MLR alternative, using factor command
mfull_alternative <- lm(Flavor~ factor(Processing.Method) + Aroma + Aftertaste +
Body + Acidity + Balance + Sweetness + Uniformity + Moisture, dat=coffee)
# Chunk 3
wet_reg <- lm(wet ~ semi + Aroma + Aftertaste + Body + Acidity + Balance +
Sweetness + Uniformity + Moisture,dat=coffee)
summary(wet_reg)
r2_wet <- summary(wet_reg)$r.squared
r2_wet
# Chunk 4
VIF_wet <- 1 / (1 - r2_wet)
VIF_wet
# Chunk 5
Aroma_reg <- lm(Aroma ~ wet + semi + Aftertaste +
Body + Acidity + Balance + Sweetness + Uniformity + Moisture, dat=coffee)
r2_Aroma <- summary(Aroma_reg)$r.squared
r2_Aroma
VIF_Aroma <- 1 / (1 - r2_Aroma)
VIF_Aroma
# Chunk 6
Aftertaste_reg <- lm(Aftertaste ~ wet + semi + Aroma +
Body + Acidity + Balance + Sweetness + Uniformity + Moisture, dat=coffee)
r2_Aftertaste <- summary(Aftertaste_reg)$r.squared
r2_Aftertaste
VIF_Aftertaste <- 1 / (1 - r2_Aftertaste)
VIF_Aftertaste
library(car)
vif(mfull) # VIF function in the "car" library
# Chunk 7
## Python in FL everglades example (2017)
## Sex, length, total mass, fat mass, and specimen condition data for
## 248 Burmese pythons (Python bivittatus) collected in the Florida Everglades
python <- read.csv("FLpython.csv")
head(python)
python$male <- ifelse(python$sex == 'M', 1, 0) # 1 = M, 0 =F
cor(python[,-1])
pairs(python[,-1])
mpf <- lm(fat ~ male + svl + mass + length, data = python)
summary(mpf)
vif(mpf)
# remove "length" based on VIF
mpf2 <- lm(fat ~ male + mass + svl, data = python)
summary(mpf2)
vif(mpf2)
mpf <- lm(fat ~ male + svl + mass + length, data = python)
summary(mpf)
vif(mpf)
# Chunk 1
## Coffee example  (Coffee Quality Institute, 2018) continued
coffee <- read.csv("coffee_arabica.csv")
# cor(coffee) # doesn't work as there's a categorical variable
cor(coffee[,-1]) # e.g., remove first column
# pairs without response: pairs(coffee[,-1])
# pairs with response, this is what we want
pairs(~ Flavor + Aroma + Aftertaste + Body +
Acidity + Balance + Sweetness + Uniformity + Moisture, data=coffee)
# Code our own indicators, so that we can more easily interpret VIFs
# 1 = wet, 0 otherwise
coffee$wet <- ifelse(coffee$Processing.Method == 'Washed / Wet', 1, 0)
# 1 = semi/dry, 0 otherwise
coffee$semi <- ifelse(coffee$Processing.Method == 'Semi-washed / Semi-pulped',
1, 0)
# Chunk 2
# Full MLR with our own coded indicators
mfull <- lm(Flavor~ wet + semi + Aroma + Aftertaste +
Body + Acidity + Balance + Sweetness + Uniformity + Moisture, dat=coffee)
summary(mfull)
# Full MLR alternative, using factor command
mfull_alternative <- lm(Flavor~ factor(Processing.Method) + Aroma + Aftertaste +
Body + Acidity + Balance + Sweetness + Uniformity + Moisture, dat=coffee)
# Chunk 3
wet_reg <- lm(wet ~ semi + Aroma + Aftertaste + Body + Acidity + Balance +
Sweetness + Uniformity + Moisture,dat=coffee)
summary(wet_reg)
r2_wet <- summary(wet_reg)$r.squared
r2_wet
# Chunk 4
VIF_wet <- 1 / (1 - r2_wet)
VIF_wet
# Chunk 5
Aroma_reg <- lm(Aroma ~ wet + semi + Aftertaste +
Body + Acidity + Balance + Sweetness + Uniformity + Moisture, dat=coffee)
r2_Aroma <- summary(Aroma_reg)$r.squared
r2_Aroma
VIF_Aroma <- 1 / (1 - r2_Aroma)
VIF_Aroma
# Chunk 6
Aftertaste_reg <- lm(Aftertaste ~ wet + semi + Aroma +
Body + Acidity + Balance + Sweetness + Uniformity + Moisture, dat=coffee)
r2_Aftertaste <- summary(Aftertaste_reg)$r.squared
r2_Aftertaste
VIF_Aftertaste <- 1 / (1 - r2_Aftertaste)
VIF_Aftertaste
library(car)
vif(mfull) # VIF function in the "car" library
# Chunk 7
## Python in FL everglades example (2017)
## Sex, length, total mass, fat mass, and specimen condition data for
## 248 Burmese pythons (Python bivittatus) collected in the Florida Everglades
python <- read.csv("FLpython.csv")
head(python)
python$male <- ifelse(python$sex == 'M', 1, 0) # 1 = M, 0 =F
cor(python[,-1])
pairs(python[,-1])
mpf <- lm(fat ~ male + svl + mass + length, data = python)
summary(mpf)
vif(mpf)
# remove "length" based on VIF
mpf2 <- lm(fat ~ male + mass + svl, data = python)
summary(mpf2)
vif(mpf2)
summary(mpf)
summary(mpf)
mpf_t <- lm(length ~ male + svl + mass, data=python)
summary(mpf_t)
summary(mpf)
summary(mpf_t)
summary(mpf_t)$r.squared
1/(1-summary(mpf_t)$r.squared)
1/(1-summary(mpf_t)$r.squared)
summary(mpf2)
summary(mpf)
source('~/Documents/university-notes/year-3/semester-1/STAT 331/figures/model-selection-basic.R', echo=TRUE)
mfull <- lm(Flavor~ factor(Processing.Method) + Aroma + Aftertaste +
Body + Acidity + Balance + Sweetness + Uniformity + Moisture, dat=coffee)
## Coffee example  (Coffee Quality Institute, 2018) continued
coffee <- read.csv("coffee_arabica.csv")
mfull <- lm(Flavor~ factor(Processing.Method) + Aroma + Aftertaste +
Body + Acidity + Balance + Sweetness + Uniformity + Moisture, dat=coffee)
summary(mfull)$adj.r.squared
AIC(mfull)
anova(mfull)
names(anova(mfull))
res <- anova(mfull)$"Sum Sq"[11]
anova(mfull)$"Sum Sq"[11]
anova(mfull)$"Sum Sq"[10]
res <- anova(mfull)$"Sum Sq"[10]
n <- nrow(coffee)
n
n <- nrow(coffee)
p <- 10
n*(res/n)+2(10+1)
n*(res/n)+2(p+1)
res <- anova(mfull)$"Sum Sq"[10]
n <- nrow(coffee)
p <- 10
n*(res/n)+2(p+1)
n*(res/n)+2*(p+1)
AIC(mfull)
res <- anova(mfull)$"Sum Sq"[10]
anova(mfull)
n*log(res/n)+2*(p+1)
AIC(mfull)
n*ln(res/n)+2*(p+1)
n*log(res/n)+2*(p+1)
log(e)
log(2.7)
n*log(res/n)+2*(p+1)
n*log(res/n)+2*(10)
n*log(res/n)+2*(p+1)
AIC(mfull)
anova(mfull)
n
n*log(res/n)+2*(p+1)
AIC(mfull)
AIC(mfull)
AIC(mfull2)
mfull2 <- lm(Flavor~ factor(Processing.Method) + Aftertaste +
Body + Acidity + Balance + Sweetness + Uniformity + Moisture, dat=coffee)
AIC(mfull2)
res2 <- anova(mfull)$"Sum Sq"[9]
res2
res2 <- anova(mfull2)$"Sum Sq"[9]
res2
res1 <- anova(mfull)$"Sum Sq"[10]
res1
AIC(mfull)
AIC(mfull2)
n*log(res1/n)+2*(10+1)
n*log(res2/n)+2(9+1)
n*log(res1/n)+2*(10+1)
n*log(res2/n)+2*(9+1)
n*log(res1/n)+2*(10+1)
n*log(res2/n)+2*(9+1)
n*log(res1/n)+log(n)*(10+1)
n*log(res1/n)+log(n)*(10+1)
n*log(res2/n)+log(n)*(9+1)
BIC(mfull)
BIC(mfull2)
# Chunk 1
## Coffee example  (Coffee Quality Institute, 2018) continued
coffee <- read.csv("coffee_arabica.csv")
mfull <- lm(Flavor~ factor(Processing.Method) + Aroma + Aftertaste +
Body + Acidity + Balance + Sweetness + Uniformity + Moisture, dat=coffee)
summary(mfull)$adj.r.squared
AIC(mfull)
BIC(mfull)
library(leaps)
all_regs <- regsubsets(Flavor ~ ., data = coffee, nvmax = 10, nbest = 2^10, really.big = TRUE)
all_regs_summ <- summary(all_regs)
all_regs_summ$which
all_regs_summ$adjr2
all_regs_summ$bic
# Organize results according to number of variables in model
p <- 10
k <- c(rep(1, choose(p,1)),
rep(2, choose(p,2)),
rep(3, choose(p,3)),
rep(4, choose(p,4)),
rep(5, choose(p,5)),
rep(6, choose(p,6)),
rep(7, choose(p,7)),
rep(8, choose(p,8)),
rep(9, choose(p,9)),
rep(10, choose(p,10)))
boxplot(all_regs_summ$adjr2 ~ k, xlab = "Number of predictors", ylab = expression(R[adj]^2), ylim = c(0,1))
abline(h = c(0,1), lty = 2, col = "red")
boxplot(all_regs_summ$bic ~ k, xlab = "Number of predictors", ylab = "BIC")
max(all_regs_summ$adjr2)
bestR2adj <- which.max(all_regs_summ$adjr2)
min(all_regs_summ$bic)
bestBIC <- which.min(all_regs_summ$bic)
# Find out which predictors in those models
all_regs_summ$which[bestR2adj,]
all_regs_summ$which[bestBIC,]
coffee$wet <- ifelse(coffee$Processing.Method == 'Washed / Wet', 1, 0) # 1 = wet, 0 otherwise
coffee$semi <- ifelse(coffee$Processing.Method == 'Semi-washed / Semi-pulped', 1, 0) # 1 = semi/dry, 0 otherwise
coffee$Processing.Method <- NULL
m_bestr2adj <- lm(Flavor~ wet + Aroma + Aftertaste +
Body + Acidity + Balance + Sweetness + Uniformity + Moisture, dat=coffee)
summary(m_bestr2adj)
AIC(m_bestr2adj)
BIC(m_bestr2adj)
m_bestBIC <- lm(Flavor~ wet + Aroma + Aftertaste +
Body + Acidity + Sweetness , dat=coffee)
summary(m_bestBIC)
AIC(m_bestBIC)
BIC(m_bestBIC)
# Let's also try stepwise methods
library(MASS)
# Full model and empty model with just intercept
full <- lm(Flavor ~ ., data = coffee)
empty <- lm(Flavor ~ 1, data = coffee)
# default stepAIC uses AIC criterion
stepAIC(object = empty, scope = list(upper = full, lower = empty), direction = "forward")
# Let's get stepAIC to use BIC by specifying the penalty k = log(n)
# Forward
stepAIC(object = empty, scope = list(upper = full, lower = empty), direction = "forward", k = log(nrow(coffee)))
m_f <- stepAIC(object = empty, scope = list(upper = full, lower = empty), direction = "forward", trace = 0, k = log(nrow(coffee)))
summary(m_f)
# Backward
stepAIC(object = full, scope = list(upper = full, lower = empty), direction = "backward", k = log(nrow(coffee)))
m_b <- stepAIC(object = full, scope = list(upper = full, lower = empty), direction = "backward", trace = 0, k = log(nrow(coffee)))
summary(m_b)
# Forward-backward
stepAIC(object = empty, scope = list(upper = full, lower = empty), direction = "both", k = log(nrow(coffee)))
m_h <- stepAIC(object = empty, scope = list(upper = full, lower = empty), direction = "both", trace = 0, k = log(nrow(coffee)))
summary(m_h)
# 10 variables is still a fairly small problem:  in this example
# all 3 approaches identify the same BIC-based model as the exhaustive search.
# Let's get stepAIC to use BIC by specifying the penalty k = log(n)
# Forward
stepAIC(object = empty, scope = list(upper = full, lower = empty), direction = "forward", k = log(nrow(coffee)))
# Full model and empty model with just intercept
full <- lm(Flavor ~ ., data = coffee)
empty <- lm(Flavor ~ 1, data = coffee)
# default stepAIC uses AIC criterion
stepAIC(object = empty, scope = list(upper = full, lower = empty), direction = "forward")
# default stepAIC uses AIC criterion
stepAIC(object = empty, scope = list(upper = full, lower = empty), direction = "forward")
m_f <- stepAIC(object = empty, scope = list(upper = full, lower = empty), direction = "forward", trace = 0, k = log(nrow(coffee)))
m_f <- stepAIC(object = empty, scope = list(upper = full, lower = empty), direction = "forward", trace = 0, k = log(nrow(coffee)))
summary(m_f)
m_bestr2adj <- lm(Flavor~ wet + Aroma + Aftertaste +
Body + Acidity + Balance + Sweetness + Uniformity + Moisture, dat=coffee)
summary(m_bestr2adj)
AIC(m_bestr2adj)
BIC(m_bestr2adj)
all_regs_summ$which
all_regs_summ$adjr2
source('~/Documents/university-notes/year-3/semester-1/STAT 331/figures/residual-plots.R', echo=TRUE)
source('~/Documents/university-notes/year-3/semester-1/STAT 331/figures/residual-plots.R', echo=TRUE)
source('~/Documents/university-notes/year-3/semester-1/STAT 331/figures/residual-plots.R', echo=TRUE)
vif(mpf2)
# Chunk 1
## Coffee example  (Coffee Quality Institute, 2018) continued
coffee <- read.csv("coffee_arabica.csv")
# cor(coffee) # doesn't work as there's a categorical variable
cor(coffee[,-1]) # e.g., remove first column
# pairs without response: pairs(coffee[,-1])
# pairs with response, this is what we want
pairs(~ Flavor + Aroma + Aftertaste + Body +
Acidity + Balance + Sweetness + Uniformity + Moisture, data=coffee)
# Code our own indicators, so that we can more easily interpret VIFs
# 1 = wet, 0 otherwise
coffee$wet <- ifelse(coffee$Processing.Method == 'Washed / Wet', 1, 0)
# 1 = semi/dry, 0 otherwise
coffee$semi <- ifelse(coffee$Processing.Method == 'Semi-washed / Semi-pulped',
1, 0)
# Chunk 2
# Full MLR with our own coded indicators
mfull <- lm(Flavor~ wet + semi + Aroma + Aftertaste +
Body + Acidity + Balance + Sweetness + Uniformity + Moisture, dat=coffee)
summary(mfull)
# Full MLR alternative, using factor command
mfull_alternative <- lm(Flavor~ factor(Processing.Method) + Aroma + Aftertaste +
Body + Acidity + Balance + Sweetness + Uniformity + Moisture, dat=coffee)
# Chunk 3
wet_reg <- lm(wet ~ semi + Aroma + Aftertaste + Body + Acidity + Balance +
Sweetness + Uniformity + Moisture,dat=coffee)
summary(wet_reg)
r2_wet <- summary(wet_reg)$r.squared
r2_wet
# Chunk 4
VIF_wet <- 1 / (1 - r2_wet)
VIF_wet
# Chunk 5
Aroma_reg <- lm(Aroma ~ wet + semi + Aftertaste +
Body + Acidity + Balance + Sweetness + Uniformity + Moisture, dat=coffee)
r2_Aroma <- summary(Aroma_reg)$r.squared
r2_Aroma
VIF_Aroma <- 1 / (1 - r2_Aroma)
VIF_Aroma
# Chunk 6
Aftertaste_reg <- lm(Aftertaste ~ wet + semi + Aroma +
Body + Acidity + Balance + Sweetness + Uniformity + Moisture, dat=coffee)
r2_Aftertaste <- summary(Aftertaste_reg)$r.squared
r2_Aftertaste
VIF_Aftertaste <- 1 / (1 - r2_Aftertaste)
VIF_Aftertaste
library(car)
vif(mfull) # VIF function in the "car" library
# Chunk 7
## Python in FL everglades example (2017)
## Sex, length, total mass, fat mass, and specimen condition data for
## 248 Burmese pythons (Python bivittatus) collected in the Florida Everglades
python <- read.csv("FLpython.csv")
head(python)
python$male <- ifelse(python$sex == 'M', 1, 0) # 1 = M, 0 =F
cor(python[,-1])
pairs(python[,-1])
mpf <- lm(fat ~ male + svl + mass + length, data = python)
summary(mpf)
vif(mpf)
mpf_l <- lm(length ~ male + svl + mass, data=python)
1/(1-summary(mpf_l)$r.squared)
# Chunk 8
# remove "length" based on VIF
mpf2 <- lm(fat ~ male + mass + svl, data = python)
summary(mpf2)
vif(mpf2)
anova(mpf2)
summary(mpf2)
summary(mpf2)$adj
aic(mpf2)
AIC(mpf2)
summary(mpf2)$sigma
360.1876^2/0.8957164
var(python)
var(python$fat)
clear
summary(mpf2)
360.2^2/0.897
var(python$fat)
summary(mpf2)$adj
360.2^2/0.8957164
summary(mpf2)$sigma
(360.1876)^2/0.8957164
var(python$fat)
var(python$fat)/3
var(python$fat)/4
var(python$fat)/6
(360.1876)^2/0.8957164
anova(mpf2)
(360.1876)^2
summary(mpf2)$adj
129735/0.8957164
summary(mpf2)
var(python$fat)
# Chunk 1
### Residual plots/diagnostics demo
## Florida oranges revisited
dat <- read.csv("florange.csv")
plot(dat$acres,dat$boxes)
lm.1 <- lm(dat$boxes~dat$acres)
summary(lm.1)
# Residual plot: vs fitted values
plot(lm.1$fitted.values, lm.1$residuals, xlab = "Fitted Values", ylab = "Residuals")
# Residual plot: vs predictor (just one in this case)
plot(dat$acres, lm.1$residuals, xlab = "Acres", ylab = "Residuals")
# Residual plot: vs i (just to demo plot; no time/space ordering here)
plot(1:nrow(dat), lm.1$residuals, xlab = "Index", ylab = "Residuals")
# Histogram of residuals
hist(lm.1$residuals)
# QQ plot of residuals
qqnorm(lm.1$residuals)
qqline(lm.1$residuals, col="blue", lwd = 2)
## Rocket data revisited
rocket <- read.csv(file="rocket.csv")
mr <- lm(thrust ~ nozzle + propratio, data = rocket)
summary(mr)
# Residual plot: vs fitted values
plot(mr$fitted.values, mr$residuals, xlab = "Fitted Values",
ylab = "Residuals")
# Residual plot: vs predictors
plot(rocket$nozzle, mr$residuals, xlab = "Nozzle (1 = large)",
ylab = "Residuals")
plot(rocket$propratio, mr$residuals, xlab = "Propellant to fuel ratio",
ylab = "Residuals")
# Histogram of residuals
hist(mr$residuals)
# QQ plot of residuals
qqnorm(mr$residuals)
qqline(mr$residuals, col="blue", lwd = 2)
