\chapter*{V2: Symmetric-Key Cryptography}
\addcontentsline{toc}{chapter}{V2: Symmetric-Key Cryptography}
\setcounter{chapter}{1}

\section*{V2a: Basic Concepts}
\addcontentsline{toc}{section}{V2a: Basic Concepts}
\setcounter{section}{1}

\begin{Definition}{Symmetric-key Encryption Scheme (SKES)}{}
      A \textbf{symmetric-key encryption scheme} (SKES) consists of:
      \begin{itemize}
            \item $ M $: the plaintext space,
            \item $ C $: the ciphertext space,
            \item $ K $: the key space,
            \item a family of encryption functions, $ E_k $: $ M\to C $,
                  $ \forall k\in K $,
            \item a family of decryption functions, $ D_k $: $ C\to M $,
                  $ \forall k \in K $, such that $ D_k(E_k(m))=m $ for
                  all $ m\in M $, $ k\in K $.
      \end{itemize}
\end{Definition}
\subsection*{Using a SKES to Achieve Confidentiality}
TODO Image
\begin{enumerate}
      \item Alice and Bob agree on a \emph{secret key} $ k\in K $
            by communicating over the \emph{secure channel}.
      \item Alice computes $ c=E_k(m) $ and sends the ciphertext
            $ c $ to Bob over the \emph{unsecured channel}.
      \item Bob retrieves the plaintext by computing $ m=D_k(c) $.
\end{enumerate}

\subsection*{The Simple Substitution Cipher}
\begin{itemize}
      \item $M=$ all English messages.
      \item $C=$ all encrypted messages.
      \item $K=$ all permutations of the English alphabet.
      \item $E_{k}(m)$: Apply permutation $k$ to $m$, one letter at a time.
      \item $D_{k}(c)$: Apply inverse permutation $k^{-1}$ to $c$, one letter at a time.
\end{itemize}
\begin{Example}{The Simple Substitution Cipher}{}
      \begin{center}
            $k=$\;\;\begin{tabularx}{0.7\linewidth}{@{}YYYYYYYYYYYYYYYYYYYYYYYYYY@{}}
                  a & b & c & d & e & f & g & h & i & j & k & l & m & n & o & p & q & r & s & t & u & v & w & x & y & z \\
                  D & N & X & E & S & K & O & J & T & A & F & P & Y & I & Q & U & B & R & Z & G & V & C & H & M & W & L
            \end{tabularx}
      \end{center}
      Encryption: $ m= $ the big dog, $ c=E_k(\text{the big dog})= $ GJS NTO EQO\@.

      Decryption: $ c= $ GJS NTO EQO, $ m=E_k^{-1}(\text{GJS NTO EQO})= $
      the big dog.
\end{Example}

\underline{Question}: Is the simple substitution cipher a secure SKES\@?

\subsection*{What Does it Mean for a SKES to be Secure?}
We need a \emph{security definition}.
\begin{enumerate}
      \item What are the computational powers of the adversary?
      \item How does the adversary interact with the two communicating parties?
      \item What is the adversary's goal?
\end{enumerate}
\begin{itemize}
      \item \emph{Security model}: Defines the computational
            abilities of the adversary, and how she interacts
            with the communicating parties.
      \item \emph{Basic assumption}: The adversary knows everything about the
            SKES, except the particular key $k$ chosen by Alice and Bob
            \underline{(Avoid security by obscurity!!)}
\end{itemize}
\subsection*{Computational Power of the Adversary}
\begin{itemize}
      \item \emph{Information-theoretic security}: Eve has infinite computational resources.
      \item \emph{Complexity-theoretic security}: Eve is a `polynomial-time Turing machine'
      \item \emph{Computational security}: Eve has 36,768 Intel E5--2683
            V4 cores running at $2.1 \text{GHz}$ at her disposal.
            \begin{itemize}
                  \item \href{https://docs.computecanada.ca/wiki/Graham}{
                              See: \emph{Graham} in the basement of MC}
            \end{itemize}
            We say: Eve is ``computationally bounded.''
\end{itemize}
In this course, we will be concerned with computational security.

\subsection*{Adversary's Interaction}
\textbf{Passive attacks}:
\begin{itemize}
      \item Ciphertext-only attack: The adversary knows some ciphertext (that was generated by Alice or Bob).
      \item Known-plaintext attack: The adversary also \underline{knows}
            some plaintext and the corresponding ciphertext.
\end{itemize}

\textbf{Active attacks}:
\begin{itemize}
      \item Chosen-plaintext attack: The adversary can also \underline{choose} some
            plaintext and obtains the corresponding ciphertext.
\end{itemize}
\textbf{Other attacks} (not considered in this course):
\begin{itemize}
      \item Clandestine attacks: bribery, blackmail, etc. Side-channel attacks: monitor the encryption and decryption equipment
            (timing attacks, power analysis attacks, electromagnetic-radiation analysis, etc.)
\end{itemize}

\subsection*{Adversary's Goal}
\begin{enumerate}
      \item Recover the secret key.
      \item Systematically recover plaintext from
            ciphertext (without necessarily learning the secret key).
      \item Learn \emph{some} partial information about the plaintext
            from the ciphertext (other than its length).
\end{enumerate}
\begin{itemize}
      \item If the adversary can achieve 1 or 2,
            the SKES is said to be \emph{totally insecure} (or \emph{totally broken}).
      \item If the adversary cannot learn any partial information about
            the plaintext from the ciphertext (except possibly its length), the
            SKES is said to be \emph{semantically secure}.
\end{itemize}

\subsection*{Definition of a Secure SKES}
\begin{Definition}{Secure SKES}{}
      A symmetric-key
      encryption scheme is said to be \textbf{secure}
      if it is semantically secure against chosen
      plaintext attack by a computationally bounded adversary.
\end{Definition}

To \emph{break} a symmetric-key encryption scheme,
the adversary has to accomplish the following:
\begin{enumerate}
      \item 1. The adversary is given a challenge ciphertext
            $c$ (generated by Alice or Bob using their secret key $k$).
      \item During its computation, the adversary can select
            plaintexts and obtains (from Alice or Bob)
            the corresponding ciphertexts.
      \item After a feasible amount of computation, the adversary
            obtains some information about the plaintext $m$ corresponding
            to the challenge ciphertext $c$ (other than the length of $m$).
\end{enumerate}

\subsection*{Desirable Properties of a SKES}
\begin{enumerate}
      \item Efficient algorithms should be known for computing $E_{k}$
            and $D_{k}$ (i.e.\ for encryption and decryption).
      \item The secret key should be small (but large enough to render exhaustive
            key search infeasible).
      \item The scheme should be secure.
      \item The scheme should be secure even against the designer of the system.
\end{enumerate}

\subsection*{Security of the Simple Substitution Cipher}
Totally insecure against a chosen-plaintext attack. [Why?]

What about security under a ciphertext-only attack?

Is \emph{exhaustive key search} possible?
\begin{itemize}
      \item  Given sufficient amounts of
            ciphertext $c$, decrypt $c$ using each possible key
            until $c$ decrypts to a plaintext message which ``makes sense.''
      \item In principle, 30 characters of ciphertext are sufficient
            on average to yield a unique plaintext that is a sensible
            English message. In practice, a few hundred characters are needed.
\end{itemize}
\emph{Exhaustive search}:
\begin{itemize}
      \item Number of keys to try is
            $26 ! \approx 4 \times 10^{26} \approx 2^{88}$.
      \item If the adversary uses $10^{6}$ computers, each
            capable of trying $10^{9}$ keys per second, then
            exhaustive key search takes about $10^{4}$ years.
      \item So, exhaustive key search is infeasible.
\end{itemize}

\subsection*{Work Factor}
In this course:
\begin{itemize}
      \item $2^{40}$ operations is considered very easy.
      \item $2^{56}$ operations is considered easy.
      \item $2^{64}$ operations is considered feasible.
      \item $2^{80}$ operations is considered barely feasible.
      \item $2^{128}$ operations is considered infeasible.
\end{itemize}
The Bitcoin network is presently performing hash operations at
the rate of $2^{66.4}$ per second (or $2^{91.3}$ per year).

The Landauer limit from thermodynamics suggests that exhaustively
trying $2^{128}$ symmetric keys would require $\gg 3000$ gigawatts of
power for one year (which is $\gg 100 \%$ of the world's energy production).

\href{http://en.wikipedia.org/wiki/Brute-force_attack}{Brute-force attack}

\subsection*{Security Level}
\begin{Definition}{Security level}{}
      A cryptographic scheme is
      said to have a \textbf{security level} of $\ell$ bits if
      the fastest known attack on the scheme takes
      approximately $2^{\ell}$ operations.
\end{Definition}
As of the year 2021, a security level of 128 bits is desirable in practice.

Of course, simple frequency analysis of ciphertext letters can be used to recover the key.
Hence, the simple substitution cipher is totally insecure even against a
ciphertext-only attack.

      [TODO Image, 52]

\subsection*{Polyalphabetic Ciphers}
\textbf{Basic idea}: Use several permutations, so a plaintext letter is
encrypted to one of several possible ciphertexts.

\begin{Example}{Vigenere cipher}{}
      \begin{itemize}
            \item Secret key is an English word having no repeated letters $s$
                  e.g. $k=$ CRYPTO\@.
            \item Example of encryption:
                  [TODO]
            \item Here, $A=0, B=1, \ldots, Z=25$; addition of letters is $ \mod 26$
            \item Decryption is subtraction modulo 26: $m=c-k$.
            \item Frequency distribution of ciphertext letters is flatter
                  (than for a simple substitution cipher).
      \end{itemize}
\end{Example}

\subsection*{Security of the Vigenere Cipher}
\begin{itemize}
      \item The Vigen√®re cipher is totally insecure against a chosen-plaintext attack. [Why?]
      \item What about security under a ciphertext-only attack?
      \item Not unexpectedly, the Vigen√®re cipher is also totally insecure against
            a ciphertext-only attack.
\end{itemize}

\subsection*{The One-Time Pad}
Invented by Vernam in 1917 for the telegraph system.

The key is a random string of letters.

\begin{Example}{Encryption}{}
\end{Example}
\begin{Remark}{}{}
      The key as as long as the plaintext.
\end{Remark}

The key should not be re-used:
\begin{itemize}
      \item If $c_{1}=m_{1}+k$ and $c_{2}=m_{2}+k$, then $c_{1}-c_{2}=m_{1}-m_{2}$
      \item Thus $c_{1}-c_{2}$ depends only on the plaintext
            (and not on the key) and hence can leak information about the plaintext.
      \item In particular, if $m_{1}$ is known, then $m_{2}$ can be easily computed.
\end{itemize}

\subsection*{Binary Messages}
Convention: From now on, unless otherwise stated, messages and keys will be assumed
to be bit strings.

\begin{Remark}{}{}
      Notation: $\oplus$ is bitwise exclusive-or (XOR)
      i.e., bitwise addition modulo 2.
\end{Remark}

\begin{Example}{Bitwise Addition Modulo 2}{}
      \[ 1011001010 \oplus 1001001001=0010000011 \]
      Note that $x \oplus x=0$ and $x \oplus y=y \oplus x$.
      Hence if $x=y \oplus z$, then $x \oplus y=z$.
\end{Example}
So, for the one-time pad:
\begin{itemize}
      \item Encryption: $c=m \oplus k$.
      \item Decryption: $m=c \oplus k$.
\end{itemize}

\begin{Example}{Reusing a Key in the One-Time Pad}{}
      TODO
\end{Example}

\subsection*{Security of the One-Time Pad}
Perfect secrecy: The one-time pad is semantically
secure against ciphertext-only attack by an adversary
with infinite computational resources.

\begin{itemize}
      \item This can be proven formally using concepts from information theory [Shannon 1949$]$.
      \item The bad news: Shannon (1949) proved that if plaintexts are $m$-bit strings,
            then any symmetric-key encryption scheme with perfect secrecy
            must have $|K| \geq 2^{m}$.
      \item So, perfect secrecy (and the one-time pad) is fairly useless in practice.
      \item All is not lost: stream ciphers
\end{itemize}

\subsection*{Stream Ciphers}
\textbf{Basic idea}: Instead of using a random key
in the one-time pad, use a ``pseudorandom'' key.

\begin{Definition}{Pseudorandom bit generator (PRBG), Seed, Keystream}{}
      A \textbf{pseudorandom bit generator} (PRBG) is a
      deterministic algorithm that takes as input a (random) \textbf{seed},
      and outputs a longer ``pseudorandom'' sequence called the \textbf{keystream}.
\end{Definition}

Using a PRBG for encryption (a stream cipher):
\begin{itemize}
      \item The seed is the secret key shared by Alice and Bob.
\end{itemize}
[TODO Image]
No more perfect secrecy --- security depends on the quality of the PRBG\@.

\subsection*{Security Requirements for the PRBG}
\begin{itemize}
      \item The keystream should be ``indistinguishable'' from a random sequence
            (the indistinguishability requirement).
      \item If an adversary knows a portion $c_{1}$ of ciphertext and the corresponding
            plaintext $m_{1}$, then she can easily find the corresponding
            portion $k_{1}=c_{1} \oplus m_{1}$ of the keystream.
            Thus, given portions of the keystream, it should be
            infeasible to learn any information about the rest of
            the keystream (the unpredictability requirement).
      \item Aside: Don't use UNIX random number
            generators (\code{rand} and \code{srand}) for cryptography!
            \begin{itemize}
                  \item $X_{0}=$ seed, $X_{i+1}=a X_{i}+b \bmod n $, $ i \geq 0 $.
                  \item $a, b$ and $n$ are fixed and public.
            \end{itemize}
\end{itemize}

\subsection*{The RC4 Steam Cipher}
Designed by Ron Rivest in 1987.
\begin{itemize}
      \item Until recently, was widely used in commercial products including
            Adobe Acrobat, Windows password encryption, Oracle secure SQL, TLS, etc.
      \item Pros: Extremely simple; extremely fast; variable key length.
            No catastrophic weakness has been found.
      \item Cons: Design criteria are proprietary;
            not much public scrutiny until the year 2001.
      \item  RC4 has two components: (i) a key scheduling algorithm, and (ii) a keystream generator.
\end{itemize}

\subsection*{RC4 Key Scheduling Algorithm}
In the following, $K[i], \bar{K}[i]$ and $S[i]$ are 8 -bit integers (bytes).
      [TODO Alg]

Idea: $S$ is a ``random-looking'' permutation of
$\set{0,1,2, \ldots, 255}$ that is generated from the secret key.

\subsection*{RC4 Keystream Generator}
[TODO Alg]

ENCRYPTION\@: The keystream bytes are XOR'd with the
plaintext bytes to produce ciphertext bytes.

\subsection*{Wireless Security}
\begin{itemize}
      \item Wireless networks have become prevalent.
      \item Popular standards for wireless networks:
            \begin{itemize}
                  \item IEEE 802.11
                        (longer range, higher speeds, commonly used for wireless LANs).
                  \item Bluetooth (short range, low speed).
            \end{itemize}
      \item New security concerns:
      \item More attack opportunities (no need for physical access).
      \item Attack from a distance $(>1 \mathrm{~km}$ with good antennae).
      \item No physical evidence of attack.
\end{itemize}

\subsection*{Case Study: IEEE 802.11 Security}
\begin{itemize}
      \item IEEE 802.11 standard for wireless LAN communications includes a protocol called Wired Equivalent Privacy (WEP).
      \item Ratified in September $1999$.
      \item Multiple amendments: 802.11a (1999), 802.11b (1999),
            802.11g (2003), 802.11i (2004), 802.11n (2009), etc.\
      \item WEP's goal is (only) to protect link-level data during wireless transmission
            between mobile stations and access points.
            TODO
\end{itemize}

\subsection*{Main Security Goals of WEP}
\begin{enumerate}
      \item Confidentiality: Prevent casual eavesdropping.
            \begin{itemize}
                  \item RC4 is used for encryption.
            \end{itemize}
      \item Data Integrity: Prevent tampering with transmitted messages.
            \begin{itemize}
                  \item An `integrity checksum' is used.
            \end{itemize}
      \item Access Control: Protect access to a wireless network infrastructure.
            \begin{itemize}
                  \item Discard all packets that are not properly encrypted using WEP\@.
            \end{itemize}
\end{enumerate}

\subsection*{Description of WEP Protocol}
\begin{itemize}
      \item Mobile stations share a secret key $k$ with access point.
            \begin{itemize}
                  \item $k$ is either 40 bits or 104 bits in length.
                  \item The standard does not specify how the key is to be distributed.
                  \item In practice, one shared key per LAN is common; this key is manually injected
                        into each access point and mobile station; the key is not changed very frequently.
            \end{itemize}
      \item Messages are divided into packets of some fixed length (e.g. 1500 bytes).
      \item WEP uses a per-packet 24 -bit initialization vector (IV) $v$ to process each packet. WEP does not specify how the IVs are managed. In practice:
            \begin{itemize}
                  \item A random IV is generated for each packet; or
                  \item  The IV is set to 0 and incremented by 1 for each use.
            \end{itemize}
\end{itemize}
To send a packet $m$, an entity does the following:
\begin{enumerate}
      \item Select a 24-bit IV $v$.
      \item Compute a 32-bit checksum: $S=\operatorname{CRC}(m)$.
            \begin{itemize}
                  \item 802.11 specifies that a CRC-32 checksum be used. CRC-32 is linear.
                        That is, for any two messages $m_{1}$ and $m_{2}$ of the same
                        bit-length,
            \end{itemize}
            \[
                  \operatorname{CRC}\left(m_{1} \oplus m_{2}\right)=\operatorname{CRC}\left(m_{1}\right) \oplus \operatorname{CRC}\left(m_{2}\right)
            \]
            (The details of CRC-32 are not important to us)
      \item Compute $c=(m \| S) \oplus \operatorname{RC} 4(v \| k)$.
            \begin{itemize}
                  \item $\|$ (and also a comma) denotes concatenation
                  \item $(v \| k)$ is the key used in the RC4 stream cipher.
            \end{itemize}
      \item Send $(v, c)$ over the wireless channel.
\end{enumerate}

TODO image

The receiver of $(v, c)$ does the following:
\begin{enumerate}
      \item Compute $(m \| S)=c \oplus \operatorname{RC} 4(v \| k)$.
      \item Compute $S^{\prime}=\operatorname{CRC}(m)$; reject the packet if $S^{\prime} \neq S$.
\end{enumerate}
\underline{Question}: Are confidentiality, data integrity,
and access control achieved?

\underline{Answer}: NO\@! (Borisov, Goldberg \& Wagner; 2001)

\subsection*{Problem 1: IV Collision}
\begin{itemize}
      \item Suppose that two packets $(v, c)$ and $\left(v, c^{\prime}\right)$
            use the same IV $v$. Let $m, m^{\prime}$ be the corresponding plaintexts.
            Then $c \oplus c^{\prime}=(m \| S) \oplus\left(m^{\prime} \| S^{\prime}\right) $.
            Thus, the eavesdropper can
            compute $m \oplus m^{\prime}$.
      \item If $m$ is known, then $m^{\prime}$ is immediately available.
      \item If $m$ is not known, then one may be able to use the
            expected distribution of $m$ and $m^{\prime}$ to discover information
            about them. (Some contents of network traffic is predictable.)
\end{itemize}
\subsection*{Finding IV Collisions}
\begin{itemize}
      \item Since there are only $2^{24}$ choices for the IV, collisions are
            guaranteed after enough time --- a few days on a busy network
            (5 Mbps).
      \item If IVs are randomly selected, then one can expect a collision after about $2^{12}$ packets.
      \item Birthday paradox: Suppose that an urn contains $n$ numbered balls. Suppose that balls are drawn from the urn, one at a time, with replacement. The expected number of draws before a ball is selected for a second time (called a collision) is approximately $\sqrt{\pi n / 2} \approx \sqrt{n}$.
      \item Collisions are more likely if keys $k$ are long-lived and the same key is used for multiple mobile stations in a network.
      \item Conclusion: WEP does not provide a high degree of confidentiality.
\end{itemize}

\subsection*{Problem 2: Checksum is Linear}
\begin{itemize}
      \item CRC-32 is used to check integrity. This is fine for random errors, but not for deliberate ones.
      \item It is easy to make controlled changes to (encrypted) packets:
      \item Suppose $(v, c)$ is an encrypted packet.
      \item Let $c=\operatorname{RC} 4(v \| k) \oplus(m \| S)$,
            where $k, m, S$ are unknown.
      \item Let $m^{\prime}=m \oplus \Delta$, where $\Delta$ is a bit string. (The 1's in $\Delta$ correspond to the bits of $m$ an attacker wishes to change.)
      \item Let $c^{\prime}=c \oplus(\Delta \| \operatorname{CRC}(\Delta))$.
      \item Then $\left(v, c^{\prime}\right)$ is a valid encrypted packet for $m^{\prime}$. [Exercise: Prove this]
      \item Conclusion: WEP does not provide data integrity.
\end{itemize}

\subsection*{Problem 3: Integrity Function is Unkeyed}
\begin{itemize}
      \item Suppose that an attacker learns the plaintext $m$ corresponding to a single encrypted packet $(v, c)$.
      \item Then, the attacker can compute the RC4 keystream
            $\operatorname{RC} 4(v \| k)=c \oplus(m \| \operatorname{CRC}(m))$.
      \item Henceforth, the attacker can compute a valid encrypted packet for any plaintext $m^{\prime}$ of her choice:
            $\left(v, c^{\prime}\right)$,
            where $c^{\prime}=\operatorname{RC} 4(v \| k) \oplus\left(m^{\prime} \| \operatorname{CRC}\left(m^{\prime}\right)\right)$
      \item Conclusion: WEP does not provide access control.
\end{itemize}

\subsection*{A More Devastating Attack}
\begin{itemize}
      \item Fluhrer, Mantin \& Shamir, 2001.
      \item Assumptions:
            \begin{enumerate}
                  \item The same 104 -bit key $k$ is used for a long period of time.
                        Most products do this.
                  \item The IV is incremented for each packet, or a random IV is
                        selected for each packet. Most products do this.
                  \item The first plaintext byte of each packet (i.e.\ the first byte of each $m$)
                        is known to the attacker.
            \end{enumerate}
            Most wireless protocols prepend the plaintext with some header
            bytes which are non-secret.
      \item Attack: A passive adversary who can collect about 5 million
            encrypted packets can very easily recover $k$ (and thus totally break the system).
            (Details not covered in this course.)
\end{itemize}

\subsection*{Implementing the Fluhrer-Mantin-Shamir Attack}
\begin{itemize}
      \item The attack can be easily mounted in practice:
      \item Can buy a $\$ 100$ wireless card and hack drivers to capture (encrypted) packets.
      \item On a busy wireless network (5Mbps), 5 million packets
            can be captured in a few hours, and then $k$ can be immediately computed.
      \item Implementation details: A. Stubbefield, J. Ionnidis, A. Rubin,
            ``Using the Fluhrer, Mantin and Shamir attack to break WEP,'' AT\&T
            Technical Report, August 2001.
      \item Script kiddies:
            \begin{itemize}
                  \item \href{http://www.aircrack-ng.org/doku.php}{Aircrack-ng}
                  \item \href{https://sourceforge.net/projects/wepcrack}{WEPCrack}
            \end{itemize}
      \item aircrack-ptw: Breaks WEP in under 60 seconds
            (only about 40,000 packets are needed).
\end{itemize}

\subsection*{Implications of WEP Insecurity}
\begin{itemize}
      \item WEP was blamed for the 2007 theft of 45 million credit-card numbers from T.J. Maxx.
            (T.J. Maxx is an American department store chain)
      \item A subsequent class action lawsuit settled for $\$ 40,900,000$
      \item \href{http://tinyurl.com/WEP-TUMaxx}{See URL}
\end{itemize}

\subsection*{IEEE 802.11 Update}
\href{http://en.wikipedia.org/wiki/Wi-Fi_protected_Access}{WiFi-Protected Access}

WPA2 (WiFi Protected Access)
\begin{itemize}
      \item Implements the new IEEE 802.11i standard (2004).
      \item Uses the AES block cipher instead of RC4.
      \item Deployed ubiquitously in WiFi networks.
      \item But deployments of WEP are still out there.
      \item \href{https://wigle.net/stats}{URL}
      \item KRACK attack disclosed in October 2017.
\end{itemize}

WPA3
\begin{itemize}
      \item Adopted in January 2018
      \item Further improvements to WPA2.
      \item Dragonblood attack disclosed in April 2019
\end{itemize}

\subsection*{RC4 Update}
\begin{itemize}
      \item The Fluhrer-Mantin-Shamir attack exploits known
            biases in the first few bytes of the keystream.
            The attack can be defeated by discarding the
            first few bytes (e.g., 768 bytes) of the keystream. (Details omitted).
      \item As of 2013, approximately $50 \%$ of all TLS traffic was secured using RC4.
      \item 2013--2021: Because of several new
            weaknesses discovered, RC4 has been
            deprecated in applications such as TLS\@.
            (As of October $2019, \approx 11.6 \%$
            of websites have RC4 enabled,
            and only $\approx 1.1 \%$ actually use it.)
\end{itemize}
Conclusions: Don't use RC4. Instead use ChaCha20 or AES-CTR (more on these later).
